//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: service.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import GRPC
import NIO
import NIOConcurrencyHelpers
import SwiftProtobuf


/// Usage: instantiate `Macbridge_LauncherClient`, then call methods of this protocol to make API calls.
internal protocol Macbridge_LauncherClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Macbridge_LauncherClientInterceptorFactoryProtocol? { get }

  func openApp(
    _ request: Macbridge_LauncherOpenAppInput,
    callOptions: CallOptions?
  ) -> UnaryCall<Macbridge_LauncherOpenAppInput, Macbridge_LauncherOpenAppReply>
}

extension Macbridge_LauncherClientProtocol {
  internal var serviceName: String {
    return "macbridge.Launcher"
  }

  /// Unary call to openApp
  ///
  /// - Parameters:
  ///   - request: Request to send to openApp.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func openApp(
    _ request: Macbridge_LauncherOpenAppInput,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Macbridge_LauncherOpenAppInput, Macbridge_LauncherOpenAppReply> {
    return self.makeUnaryCall(
      path: Macbridge_LauncherClientMetadata.Methods.openApp.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeopenAppInterceptors() ?? []
    )
  }
}

#if compiler(>=5.6)
@available(*, deprecated)
extension Macbridge_LauncherClient: @unchecked Sendable {}
#endif // compiler(>=5.6)

@available(*, deprecated, renamed: "Macbridge_LauncherNIOClient")
internal final class Macbridge_LauncherClient: Macbridge_LauncherClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Macbridge_LauncherClientInterceptorFactoryProtocol?
  internal let channel: GRPCChannel
  internal var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  internal var interceptors: Macbridge_LauncherClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the macbridge.Launcher service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Macbridge_LauncherClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

internal struct Macbridge_LauncherNIOClient: Macbridge_LauncherClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Macbridge_LauncherClientInterceptorFactoryProtocol?

  /// Creates a client for the macbridge.Launcher service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Macbridge_LauncherClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

#if compiler(>=5.6)
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol Macbridge_LauncherAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Macbridge_LauncherClientInterceptorFactoryProtocol? { get }

  func makeOpenAppCall(
    _ request: Macbridge_LauncherOpenAppInput,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Macbridge_LauncherOpenAppInput, Macbridge_LauncherOpenAppReply>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Macbridge_LauncherAsyncClientProtocol {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return Macbridge_LauncherClientMetadata.serviceDescriptor
  }

  internal var interceptors: Macbridge_LauncherClientInterceptorFactoryProtocol? {
    return nil
  }

  internal func makeOpenAppCall(
    _ request: Macbridge_LauncherOpenAppInput,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Macbridge_LauncherOpenAppInput, Macbridge_LauncherOpenAppReply> {
    return self.makeAsyncUnaryCall(
      path: Macbridge_LauncherClientMetadata.Methods.openApp.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeopenAppInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Macbridge_LauncherAsyncClientProtocol {
  internal func openApp(
    _ request: Macbridge_LauncherOpenAppInput,
    callOptions: CallOptions? = nil
  ) async throws -> Macbridge_LauncherOpenAppReply {
    return try await self.performAsyncUnaryCall(
      path: Macbridge_LauncherClientMetadata.Methods.openApp.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeopenAppInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal struct Macbridge_LauncherAsyncClient: Macbridge_LauncherAsyncClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Macbridge_LauncherClientInterceptorFactoryProtocol?

  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Macbridge_LauncherClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

#endif // compiler(>=5.6)

internal protocol Macbridge_LauncherClientInterceptorFactoryProtocol: GRPCSendable {

  /// - Returns: Interceptors to use when invoking 'openApp'.
  func makeopenAppInterceptors() -> [ClientInterceptor<Macbridge_LauncherOpenAppInput, Macbridge_LauncherOpenAppReply>]
}

internal enum Macbridge_LauncherClientMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Launcher",
    fullName: "macbridge.Launcher",
    methods: [
      Macbridge_LauncherClientMetadata.Methods.openApp,
    ]
  )

  internal enum Methods {
    internal static let openApp = GRPCMethodDescriptor(
      name: "openApp",
      path: "/macbridge.Launcher/openApp",
      type: GRPCCallType.unary
    )
  }
}

/// Usage: instantiate `Macbridge_ElementClient`, then call methods of this protocol to make API calls.
internal protocol Macbridge_ElementClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Macbridge_ElementClientInterceptorFactoryProtocol? { get }

  func find(
    _ request: Macbridge_ElementFindInput,
    callOptions: CallOptions?
  ) -> UnaryCall<Macbridge_ElementFindInput, Macbridge_ElementFindReply>

  func listAttr(
    _ request: Macbridge_ElementListAttrInput,
    callOptions: CallOptions?
  ) -> UnaryCall<Macbridge_ElementListAttrInput, Macbridge_ElementListAttrReply>

  func listAction(
    _ request: Macbridge_ElementListActionInput,
    callOptions: CallOptions?
  ) -> UnaryCall<Macbridge_ElementListActionInput, Macbridge_ElementListActionReply>

  func getAttr(
    _ request: Macbridge_ElementGetAttrInput,
    callOptions: CallOptions?
  ) -> UnaryCall<Macbridge_ElementGetAttrInput, Macbridge_ElementGetAttrReply>

  func putAttr(
    _ request: Macbridge_ElementPutAttrInput,
    callOptions: CallOptions?
  ) -> UnaryCall<Macbridge_ElementPutAttrInput, Macbridge_ElementPutAttrReply>

  func performAction(
    _ request: Macbridge_ElementPerformActionInput,
    callOptions: CallOptions?
  ) -> UnaryCall<Macbridge_ElementPerformActionInput, Macbridge_ElementPerformActionReply>
}

extension Macbridge_ElementClientProtocol {
  internal var serviceName: String {
    return "macbridge.Element"
  }

  /// Unary call to find
  ///
  /// - Parameters:
  ///   - request: Request to send to find.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func find(
    _ request: Macbridge_ElementFindInput,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Macbridge_ElementFindInput, Macbridge_ElementFindReply> {
    return self.makeUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.find.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makefindInterceptors() ?? []
    )
  }

  /// Unary call to listAttr
  ///
  /// - Parameters:
  ///   - request: Request to send to listAttr.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func listAttr(
    _ request: Macbridge_ElementListAttrInput,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Macbridge_ElementListAttrInput, Macbridge_ElementListAttrReply> {
    return self.makeUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.listAttr.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makelistAttrInterceptors() ?? []
    )
  }

  /// Unary call to listAction
  ///
  /// - Parameters:
  ///   - request: Request to send to listAction.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func listAction(
    _ request: Macbridge_ElementListActionInput,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Macbridge_ElementListActionInput, Macbridge_ElementListActionReply> {
    return self.makeUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.listAction.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makelistActionInterceptors() ?? []
    )
  }

  /// Unary call to getAttr
  ///
  /// - Parameters:
  ///   - request: Request to send to getAttr.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func getAttr(
    _ request: Macbridge_ElementGetAttrInput,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Macbridge_ElementGetAttrInput, Macbridge_ElementGetAttrReply> {
    return self.makeUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.getAttr.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetAttrInterceptors() ?? []
    )
  }

  /// Unary call to putAttr
  ///
  /// - Parameters:
  ///   - request: Request to send to putAttr.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func putAttr(
    _ request: Macbridge_ElementPutAttrInput,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Macbridge_ElementPutAttrInput, Macbridge_ElementPutAttrReply> {
    return self.makeUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.putAttr.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeputAttrInterceptors() ?? []
    )
  }

  /// Unary call to performAction
  ///
  /// - Parameters:
  ///   - request: Request to send to performAction.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func performAction(
    _ request: Macbridge_ElementPerformActionInput,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Macbridge_ElementPerformActionInput, Macbridge_ElementPerformActionReply> {
    return self.makeUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.performAction.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeperformActionInterceptors() ?? []
    )
  }
}

#if compiler(>=5.6)
@available(*, deprecated)
extension Macbridge_ElementClient: @unchecked Sendable {}
#endif // compiler(>=5.6)

@available(*, deprecated, renamed: "Macbridge_ElementNIOClient")
internal final class Macbridge_ElementClient: Macbridge_ElementClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Macbridge_ElementClientInterceptorFactoryProtocol?
  internal let channel: GRPCChannel
  internal var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  internal var interceptors: Macbridge_ElementClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the macbridge.Element service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Macbridge_ElementClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

internal struct Macbridge_ElementNIOClient: Macbridge_ElementClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Macbridge_ElementClientInterceptorFactoryProtocol?

  /// Creates a client for the macbridge.Element service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Macbridge_ElementClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

#if compiler(>=5.6)
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol Macbridge_ElementAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Macbridge_ElementClientInterceptorFactoryProtocol? { get }

  func makeFindCall(
    _ request: Macbridge_ElementFindInput,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Macbridge_ElementFindInput, Macbridge_ElementFindReply>

  func makeListAttrCall(
    _ request: Macbridge_ElementListAttrInput,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Macbridge_ElementListAttrInput, Macbridge_ElementListAttrReply>

  func makeListActionCall(
    _ request: Macbridge_ElementListActionInput,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Macbridge_ElementListActionInput, Macbridge_ElementListActionReply>

  func makeGetAttrCall(
    _ request: Macbridge_ElementGetAttrInput,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Macbridge_ElementGetAttrInput, Macbridge_ElementGetAttrReply>

  func makePutAttrCall(
    _ request: Macbridge_ElementPutAttrInput,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Macbridge_ElementPutAttrInput, Macbridge_ElementPutAttrReply>

  func makePerformActionCall(
    _ request: Macbridge_ElementPerformActionInput,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Macbridge_ElementPerformActionInput, Macbridge_ElementPerformActionReply>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Macbridge_ElementAsyncClientProtocol {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return Macbridge_ElementClientMetadata.serviceDescriptor
  }

  internal var interceptors: Macbridge_ElementClientInterceptorFactoryProtocol? {
    return nil
  }

  internal func makeFindCall(
    _ request: Macbridge_ElementFindInput,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Macbridge_ElementFindInput, Macbridge_ElementFindReply> {
    return self.makeAsyncUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.find.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makefindInterceptors() ?? []
    )
  }

  internal func makeListAttrCall(
    _ request: Macbridge_ElementListAttrInput,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Macbridge_ElementListAttrInput, Macbridge_ElementListAttrReply> {
    return self.makeAsyncUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.listAttr.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makelistAttrInterceptors() ?? []
    )
  }

  internal func makeListActionCall(
    _ request: Macbridge_ElementListActionInput,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Macbridge_ElementListActionInput, Macbridge_ElementListActionReply> {
    return self.makeAsyncUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.listAction.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makelistActionInterceptors() ?? []
    )
  }

  internal func makeGetAttrCall(
    _ request: Macbridge_ElementGetAttrInput,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Macbridge_ElementGetAttrInput, Macbridge_ElementGetAttrReply> {
    return self.makeAsyncUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.getAttr.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetAttrInterceptors() ?? []
    )
  }

  internal func makePutAttrCall(
    _ request: Macbridge_ElementPutAttrInput,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Macbridge_ElementPutAttrInput, Macbridge_ElementPutAttrReply> {
    return self.makeAsyncUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.putAttr.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeputAttrInterceptors() ?? []
    )
  }

  internal func makePerformActionCall(
    _ request: Macbridge_ElementPerformActionInput,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Macbridge_ElementPerformActionInput, Macbridge_ElementPerformActionReply> {
    return self.makeAsyncUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.performAction.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeperformActionInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Macbridge_ElementAsyncClientProtocol {
  internal func find(
    _ request: Macbridge_ElementFindInput,
    callOptions: CallOptions? = nil
  ) async throws -> Macbridge_ElementFindReply {
    return try await self.performAsyncUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.find.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makefindInterceptors() ?? []
    )
  }

  internal func listAttr(
    _ request: Macbridge_ElementListAttrInput,
    callOptions: CallOptions? = nil
  ) async throws -> Macbridge_ElementListAttrReply {
    return try await self.performAsyncUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.listAttr.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makelistAttrInterceptors() ?? []
    )
  }

  internal func listAction(
    _ request: Macbridge_ElementListActionInput,
    callOptions: CallOptions? = nil
  ) async throws -> Macbridge_ElementListActionReply {
    return try await self.performAsyncUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.listAction.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makelistActionInterceptors() ?? []
    )
  }

  internal func getAttr(
    _ request: Macbridge_ElementGetAttrInput,
    callOptions: CallOptions? = nil
  ) async throws -> Macbridge_ElementGetAttrReply {
    return try await self.performAsyncUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.getAttr.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetAttrInterceptors() ?? []
    )
  }

  internal func putAttr(
    _ request: Macbridge_ElementPutAttrInput,
    callOptions: CallOptions? = nil
  ) async throws -> Macbridge_ElementPutAttrReply {
    return try await self.performAsyncUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.putAttr.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeputAttrInterceptors() ?? []
    )
  }

  internal func performAction(
    _ request: Macbridge_ElementPerformActionInput,
    callOptions: CallOptions? = nil
  ) async throws -> Macbridge_ElementPerformActionReply {
    return try await self.performAsyncUnaryCall(
      path: Macbridge_ElementClientMetadata.Methods.performAction.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeperformActionInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal struct Macbridge_ElementAsyncClient: Macbridge_ElementAsyncClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Macbridge_ElementClientInterceptorFactoryProtocol?

  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Macbridge_ElementClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

#endif // compiler(>=5.6)

internal protocol Macbridge_ElementClientInterceptorFactoryProtocol: GRPCSendable {

  /// - Returns: Interceptors to use when invoking 'find'.
  func makefindInterceptors() -> [ClientInterceptor<Macbridge_ElementFindInput, Macbridge_ElementFindReply>]

  /// - Returns: Interceptors to use when invoking 'listAttr'.
  func makelistAttrInterceptors() -> [ClientInterceptor<Macbridge_ElementListAttrInput, Macbridge_ElementListAttrReply>]

  /// - Returns: Interceptors to use when invoking 'listAction'.
  func makelistActionInterceptors() -> [ClientInterceptor<Macbridge_ElementListActionInput, Macbridge_ElementListActionReply>]

  /// - Returns: Interceptors to use when invoking 'getAttr'.
  func makegetAttrInterceptors() -> [ClientInterceptor<Macbridge_ElementGetAttrInput, Macbridge_ElementGetAttrReply>]

  /// - Returns: Interceptors to use when invoking 'putAttr'.
  func makeputAttrInterceptors() -> [ClientInterceptor<Macbridge_ElementPutAttrInput, Macbridge_ElementPutAttrReply>]

  /// - Returns: Interceptors to use when invoking 'performAction'.
  func makeperformActionInterceptors() -> [ClientInterceptor<Macbridge_ElementPerformActionInput, Macbridge_ElementPerformActionReply>]
}

internal enum Macbridge_ElementClientMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Element",
    fullName: "macbridge.Element",
    methods: [
      Macbridge_ElementClientMetadata.Methods.find,
      Macbridge_ElementClientMetadata.Methods.listAttr,
      Macbridge_ElementClientMetadata.Methods.listAction,
      Macbridge_ElementClientMetadata.Methods.getAttr,
      Macbridge_ElementClientMetadata.Methods.putAttr,
      Macbridge_ElementClientMetadata.Methods.performAction,
    ]
  )

  internal enum Methods {
    internal static let find = GRPCMethodDescriptor(
      name: "find",
      path: "/macbridge.Element/find",
      type: GRPCCallType.unary
    )

    internal static let listAttr = GRPCMethodDescriptor(
      name: "listAttr",
      path: "/macbridge.Element/listAttr",
      type: GRPCCallType.unary
    )

    internal static let listAction = GRPCMethodDescriptor(
      name: "listAction",
      path: "/macbridge.Element/listAction",
      type: GRPCCallType.unary
    )

    internal static let getAttr = GRPCMethodDescriptor(
      name: "getAttr",
      path: "/macbridge.Element/getAttr",
      type: GRPCCallType.unary
    )

    internal static let putAttr = GRPCMethodDescriptor(
      name: "putAttr",
      path: "/macbridge.Element/putAttr",
      type: GRPCCallType.unary
    )

    internal static let performAction = GRPCMethodDescriptor(
      name: "performAction",
      path: "/macbridge.Element/performAction",
      type: GRPCCallType.unary
    )
  }
}

/// Usage: instantiate `Macbridge_KeyboardClient`, then call methods of this protocol to make API calls.
internal protocol Macbridge_KeyboardClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Macbridge_KeyboardClientInterceptorFactoryProtocol? { get }

  func sendtext(
    _ request: Macbridge_KeyboardSendtextInput,
    callOptions: CallOptions?
  ) -> UnaryCall<Macbridge_KeyboardSendtextInput, Macbridge_KeyboardSendtextReply>

  func sendkeys(
    _ request: Macbridge_KeyboardSendkeysInput,
    callOptions: CallOptions?
  ) -> UnaryCall<Macbridge_KeyboardSendkeysInput, Macbridge_KeyboardSendkeysReply>
}

extension Macbridge_KeyboardClientProtocol {
  internal var serviceName: String {
    return "macbridge.Keyboard"
  }

  /// Unary call to sendtext
  ///
  /// - Parameters:
  ///   - request: Request to send to sendtext.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func sendtext(
    _ request: Macbridge_KeyboardSendtextInput,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Macbridge_KeyboardSendtextInput, Macbridge_KeyboardSendtextReply> {
    return self.makeUnaryCall(
      path: Macbridge_KeyboardClientMetadata.Methods.sendtext.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesendtextInterceptors() ?? []
    )
  }

  /// Unary call to sendkeys
  ///
  /// - Parameters:
  ///   - request: Request to send to sendkeys.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func sendkeys(
    _ request: Macbridge_KeyboardSendkeysInput,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Macbridge_KeyboardSendkeysInput, Macbridge_KeyboardSendkeysReply> {
    return self.makeUnaryCall(
      path: Macbridge_KeyboardClientMetadata.Methods.sendkeys.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesendkeysInterceptors() ?? []
    )
  }
}

#if compiler(>=5.6)
@available(*, deprecated)
extension Macbridge_KeyboardClient: @unchecked Sendable {}
#endif // compiler(>=5.6)

@available(*, deprecated, renamed: "Macbridge_KeyboardNIOClient")
internal final class Macbridge_KeyboardClient: Macbridge_KeyboardClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Macbridge_KeyboardClientInterceptorFactoryProtocol?
  internal let channel: GRPCChannel
  internal var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  internal var interceptors: Macbridge_KeyboardClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the macbridge.Keyboard service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Macbridge_KeyboardClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

internal struct Macbridge_KeyboardNIOClient: Macbridge_KeyboardClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Macbridge_KeyboardClientInterceptorFactoryProtocol?

  /// Creates a client for the macbridge.Keyboard service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Macbridge_KeyboardClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

#if compiler(>=5.6)
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol Macbridge_KeyboardAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Macbridge_KeyboardClientInterceptorFactoryProtocol? { get }

  func makeSendtextCall(
    _ request: Macbridge_KeyboardSendtextInput,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Macbridge_KeyboardSendtextInput, Macbridge_KeyboardSendtextReply>

  func makeSendkeysCall(
    _ request: Macbridge_KeyboardSendkeysInput,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Macbridge_KeyboardSendkeysInput, Macbridge_KeyboardSendkeysReply>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Macbridge_KeyboardAsyncClientProtocol {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return Macbridge_KeyboardClientMetadata.serviceDescriptor
  }

  internal var interceptors: Macbridge_KeyboardClientInterceptorFactoryProtocol? {
    return nil
  }

  internal func makeSendtextCall(
    _ request: Macbridge_KeyboardSendtextInput,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Macbridge_KeyboardSendtextInput, Macbridge_KeyboardSendtextReply> {
    return self.makeAsyncUnaryCall(
      path: Macbridge_KeyboardClientMetadata.Methods.sendtext.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesendtextInterceptors() ?? []
    )
  }

  internal func makeSendkeysCall(
    _ request: Macbridge_KeyboardSendkeysInput,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Macbridge_KeyboardSendkeysInput, Macbridge_KeyboardSendkeysReply> {
    return self.makeAsyncUnaryCall(
      path: Macbridge_KeyboardClientMetadata.Methods.sendkeys.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesendkeysInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Macbridge_KeyboardAsyncClientProtocol {
  internal func sendtext(
    _ request: Macbridge_KeyboardSendtextInput,
    callOptions: CallOptions? = nil
  ) async throws -> Macbridge_KeyboardSendtextReply {
    return try await self.performAsyncUnaryCall(
      path: Macbridge_KeyboardClientMetadata.Methods.sendtext.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesendtextInterceptors() ?? []
    )
  }

  internal func sendkeys(
    _ request: Macbridge_KeyboardSendkeysInput,
    callOptions: CallOptions? = nil
  ) async throws -> Macbridge_KeyboardSendkeysReply {
    return try await self.performAsyncUnaryCall(
      path: Macbridge_KeyboardClientMetadata.Methods.sendkeys.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesendkeysInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal struct Macbridge_KeyboardAsyncClient: Macbridge_KeyboardAsyncClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Macbridge_KeyboardClientInterceptorFactoryProtocol?

  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Macbridge_KeyboardClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

#endif // compiler(>=5.6)

internal protocol Macbridge_KeyboardClientInterceptorFactoryProtocol: GRPCSendable {

  /// - Returns: Interceptors to use when invoking 'sendtext'.
  func makesendtextInterceptors() -> [ClientInterceptor<Macbridge_KeyboardSendtextInput, Macbridge_KeyboardSendtextReply>]

  /// - Returns: Interceptors to use when invoking 'sendkeys'.
  func makesendkeysInterceptors() -> [ClientInterceptor<Macbridge_KeyboardSendkeysInput, Macbridge_KeyboardSendkeysReply>]
}

internal enum Macbridge_KeyboardClientMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Keyboard",
    fullName: "macbridge.Keyboard",
    methods: [
      Macbridge_KeyboardClientMetadata.Methods.sendtext,
      Macbridge_KeyboardClientMetadata.Methods.sendkeys,
    ]
  )

  internal enum Methods {
    internal static let sendtext = GRPCMethodDescriptor(
      name: "sendtext",
      path: "/macbridge.Keyboard/sendtext",
      type: GRPCCallType.unary
    )

    internal static let sendkeys = GRPCMethodDescriptor(
      name: "sendkeys",
      path: "/macbridge.Keyboard/sendkeys",
      type: GRPCCallType.unary
    )
  }
}

/// To build a server, implement a class that conforms to this protocol.
internal protocol Macbridge_LauncherProvider: CallHandlerProvider {
  var interceptors: Macbridge_LauncherServerInterceptorFactoryProtocol? { get }

  func openApp(request: Macbridge_LauncherOpenAppInput, context: StatusOnlyCallContext) -> EventLoopFuture<Macbridge_LauncherOpenAppReply>
}

extension Macbridge_LauncherProvider {
  internal var serviceName: Substring {
    return Macbridge_LauncherServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "openApp":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_LauncherOpenAppInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_LauncherOpenAppReply>(),
        interceptors: self.interceptors?.makeopenAppInterceptors() ?? [],
        userFunction: self.openApp(request:context:)
      )

    default:
      return nil
    }
  }
}

#if compiler(>=5.6)

/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol Macbridge_LauncherAsyncProvider: CallHandlerProvider {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Macbridge_LauncherServerInterceptorFactoryProtocol? { get }

  @Sendable func openApp(
    request: Macbridge_LauncherOpenAppInput,
    context: GRPCAsyncServerCallContext
  ) async throws -> Macbridge_LauncherOpenAppReply
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Macbridge_LauncherAsyncProvider {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return Macbridge_LauncherServerMetadata.serviceDescriptor
  }

  internal var serviceName: Substring {
    return Macbridge_LauncherServerMetadata.serviceDescriptor.fullName[...]
  }

  internal var interceptors: Macbridge_LauncherServerInterceptorFactoryProtocol? {
    return nil
  }

  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "openApp":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_LauncherOpenAppInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_LauncherOpenAppReply>(),
        interceptors: self.interceptors?.makeopenAppInterceptors() ?? [],
        wrapping: self.openApp(request:context:)
      )

    default:
      return nil
    }
  }
}

#endif // compiler(>=5.6)

internal protocol Macbridge_LauncherServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'openApp'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeopenAppInterceptors() -> [ServerInterceptor<Macbridge_LauncherOpenAppInput, Macbridge_LauncherOpenAppReply>]
}

internal enum Macbridge_LauncherServerMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Launcher",
    fullName: "macbridge.Launcher",
    methods: [
      Macbridge_LauncherServerMetadata.Methods.openApp,
    ]
  )

  internal enum Methods {
    internal static let openApp = GRPCMethodDescriptor(
      name: "openApp",
      path: "/macbridge.Launcher/openApp",
      type: GRPCCallType.unary
    )
  }
}
/// To build a server, implement a class that conforms to this protocol.
internal protocol Macbridge_ElementProvider: CallHandlerProvider {
  var interceptors: Macbridge_ElementServerInterceptorFactoryProtocol? { get }

  func find(request: Macbridge_ElementFindInput, context: StatusOnlyCallContext) -> EventLoopFuture<Macbridge_ElementFindReply>

  func listAttr(request: Macbridge_ElementListAttrInput, context: StatusOnlyCallContext) -> EventLoopFuture<Macbridge_ElementListAttrReply>

  func listAction(request: Macbridge_ElementListActionInput, context: StatusOnlyCallContext) -> EventLoopFuture<Macbridge_ElementListActionReply>

  func getAttr(request: Macbridge_ElementGetAttrInput, context: StatusOnlyCallContext) -> EventLoopFuture<Macbridge_ElementGetAttrReply>

  func putAttr(request: Macbridge_ElementPutAttrInput, context: StatusOnlyCallContext) -> EventLoopFuture<Macbridge_ElementPutAttrReply>

  func performAction(request: Macbridge_ElementPerformActionInput, context: StatusOnlyCallContext) -> EventLoopFuture<Macbridge_ElementPerformActionReply>
}

extension Macbridge_ElementProvider {
  internal var serviceName: Substring {
    return Macbridge_ElementServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "find":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_ElementFindInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_ElementFindReply>(),
        interceptors: self.interceptors?.makefindInterceptors() ?? [],
        userFunction: self.find(request:context:)
      )

    case "listAttr":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_ElementListAttrInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_ElementListAttrReply>(),
        interceptors: self.interceptors?.makelistAttrInterceptors() ?? [],
        userFunction: self.listAttr(request:context:)
      )

    case "listAction":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_ElementListActionInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_ElementListActionReply>(),
        interceptors: self.interceptors?.makelistActionInterceptors() ?? [],
        userFunction: self.listAction(request:context:)
      )

    case "getAttr":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_ElementGetAttrInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_ElementGetAttrReply>(),
        interceptors: self.interceptors?.makegetAttrInterceptors() ?? [],
        userFunction: self.getAttr(request:context:)
      )

    case "putAttr":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_ElementPutAttrInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_ElementPutAttrReply>(),
        interceptors: self.interceptors?.makeputAttrInterceptors() ?? [],
        userFunction: self.putAttr(request:context:)
      )

    case "performAction":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_ElementPerformActionInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_ElementPerformActionReply>(),
        interceptors: self.interceptors?.makeperformActionInterceptors() ?? [],
        userFunction: self.performAction(request:context:)
      )

    default:
      return nil
    }
  }
}

#if compiler(>=5.6)

/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol Macbridge_ElementAsyncProvider: CallHandlerProvider {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Macbridge_ElementServerInterceptorFactoryProtocol? { get }

  @Sendable func find(
    request: Macbridge_ElementFindInput,
    context: GRPCAsyncServerCallContext
  ) async throws -> Macbridge_ElementFindReply

  @Sendable func listAttr(
    request: Macbridge_ElementListAttrInput,
    context: GRPCAsyncServerCallContext
  ) async throws -> Macbridge_ElementListAttrReply

  @Sendable func listAction(
    request: Macbridge_ElementListActionInput,
    context: GRPCAsyncServerCallContext
  ) async throws -> Macbridge_ElementListActionReply

  @Sendable func getAttr(
    request: Macbridge_ElementGetAttrInput,
    context: GRPCAsyncServerCallContext
  ) async throws -> Macbridge_ElementGetAttrReply

  @Sendable func putAttr(
    request: Macbridge_ElementPutAttrInput,
    context: GRPCAsyncServerCallContext
  ) async throws -> Macbridge_ElementPutAttrReply

  @Sendable func performAction(
    request: Macbridge_ElementPerformActionInput,
    context: GRPCAsyncServerCallContext
  ) async throws -> Macbridge_ElementPerformActionReply
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Macbridge_ElementAsyncProvider {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return Macbridge_ElementServerMetadata.serviceDescriptor
  }

  internal var serviceName: Substring {
    return Macbridge_ElementServerMetadata.serviceDescriptor.fullName[...]
  }

  internal var interceptors: Macbridge_ElementServerInterceptorFactoryProtocol? {
    return nil
  }

  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "find":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_ElementFindInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_ElementFindReply>(),
        interceptors: self.interceptors?.makefindInterceptors() ?? [],
        wrapping: self.find(request:context:)
      )

    case "listAttr":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_ElementListAttrInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_ElementListAttrReply>(),
        interceptors: self.interceptors?.makelistAttrInterceptors() ?? [],
        wrapping: self.listAttr(request:context:)
      )

    case "listAction":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_ElementListActionInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_ElementListActionReply>(),
        interceptors: self.interceptors?.makelistActionInterceptors() ?? [],
        wrapping: self.listAction(request:context:)
      )

    case "getAttr":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_ElementGetAttrInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_ElementGetAttrReply>(),
        interceptors: self.interceptors?.makegetAttrInterceptors() ?? [],
        wrapping: self.getAttr(request:context:)
      )

    case "putAttr":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_ElementPutAttrInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_ElementPutAttrReply>(),
        interceptors: self.interceptors?.makeputAttrInterceptors() ?? [],
        wrapping: self.putAttr(request:context:)
      )

    case "performAction":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_ElementPerformActionInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_ElementPerformActionReply>(),
        interceptors: self.interceptors?.makeperformActionInterceptors() ?? [],
        wrapping: self.performAction(request:context:)
      )

    default:
      return nil
    }
  }
}

#endif // compiler(>=5.6)

internal protocol Macbridge_ElementServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'find'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makefindInterceptors() -> [ServerInterceptor<Macbridge_ElementFindInput, Macbridge_ElementFindReply>]

  /// - Returns: Interceptors to use when handling 'listAttr'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makelistAttrInterceptors() -> [ServerInterceptor<Macbridge_ElementListAttrInput, Macbridge_ElementListAttrReply>]

  /// - Returns: Interceptors to use when handling 'listAction'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makelistActionInterceptors() -> [ServerInterceptor<Macbridge_ElementListActionInput, Macbridge_ElementListActionReply>]

  /// - Returns: Interceptors to use when handling 'getAttr'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makegetAttrInterceptors() -> [ServerInterceptor<Macbridge_ElementGetAttrInput, Macbridge_ElementGetAttrReply>]

  /// - Returns: Interceptors to use when handling 'putAttr'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeputAttrInterceptors() -> [ServerInterceptor<Macbridge_ElementPutAttrInput, Macbridge_ElementPutAttrReply>]

  /// - Returns: Interceptors to use when handling 'performAction'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeperformActionInterceptors() -> [ServerInterceptor<Macbridge_ElementPerformActionInput, Macbridge_ElementPerformActionReply>]
}

internal enum Macbridge_ElementServerMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Element",
    fullName: "macbridge.Element",
    methods: [
      Macbridge_ElementServerMetadata.Methods.find,
      Macbridge_ElementServerMetadata.Methods.listAttr,
      Macbridge_ElementServerMetadata.Methods.listAction,
      Macbridge_ElementServerMetadata.Methods.getAttr,
      Macbridge_ElementServerMetadata.Methods.putAttr,
      Macbridge_ElementServerMetadata.Methods.performAction,
    ]
  )

  internal enum Methods {
    internal static let find = GRPCMethodDescriptor(
      name: "find",
      path: "/macbridge.Element/find",
      type: GRPCCallType.unary
    )

    internal static let listAttr = GRPCMethodDescriptor(
      name: "listAttr",
      path: "/macbridge.Element/listAttr",
      type: GRPCCallType.unary
    )

    internal static let listAction = GRPCMethodDescriptor(
      name: "listAction",
      path: "/macbridge.Element/listAction",
      type: GRPCCallType.unary
    )

    internal static let getAttr = GRPCMethodDescriptor(
      name: "getAttr",
      path: "/macbridge.Element/getAttr",
      type: GRPCCallType.unary
    )

    internal static let putAttr = GRPCMethodDescriptor(
      name: "putAttr",
      path: "/macbridge.Element/putAttr",
      type: GRPCCallType.unary
    )

    internal static let performAction = GRPCMethodDescriptor(
      name: "performAction",
      path: "/macbridge.Element/performAction",
      type: GRPCCallType.unary
    )
  }
}
/// To build a server, implement a class that conforms to this protocol.
internal protocol Macbridge_KeyboardProvider: CallHandlerProvider {
  var interceptors: Macbridge_KeyboardServerInterceptorFactoryProtocol? { get }

  func sendtext(request: Macbridge_KeyboardSendtextInput, context: StatusOnlyCallContext) -> EventLoopFuture<Macbridge_KeyboardSendtextReply>

  func sendkeys(request: Macbridge_KeyboardSendkeysInput, context: StatusOnlyCallContext) -> EventLoopFuture<Macbridge_KeyboardSendkeysReply>
}

extension Macbridge_KeyboardProvider {
  internal var serviceName: Substring {
    return Macbridge_KeyboardServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "sendtext":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_KeyboardSendtextInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_KeyboardSendtextReply>(),
        interceptors: self.interceptors?.makesendtextInterceptors() ?? [],
        userFunction: self.sendtext(request:context:)
      )

    case "sendkeys":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_KeyboardSendkeysInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_KeyboardSendkeysReply>(),
        interceptors: self.interceptors?.makesendkeysInterceptors() ?? [],
        userFunction: self.sendkeys(request:context:)
      )

    default:
      return nil
    }
  }
}

#if compiler(>=5.6)

/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol Macbridge_KeyboardAsyncProvider: CallHandlerProvider {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Macbridge_KeyboardServerInterceptorFactoryProtocol? { get }

  @Sendable func sendtext(
    request: Macbridge_KeyboardSendtextInput,
    context: GRPCAsyncServerCallContext
  ) async throws -> Macbridge_KeyboardSendtextReply

  @Sendable func sendkeys(
    request: Macbridge_KeyboardSendkeysInput,
    context: GRPCAsyncServerCallContext
  ) async throws -> Macbridge_KeyboardSendkeysReply
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Macbridge_KeyboardAsyncProvider {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return Macbridge_KeyboardServerMetadata.serviceDescriptor
  }

  internal var serviceName: Substring {
    return Macbridge_KeyboardServerMetadata.serviceDescriptor.fullName[...]
  }

  internal var interceptors: Macbridge_KeyboardServerInterceptorFactoryProtocol? {
    return nil
  }

  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "sendtext":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_KeyboardSendtextInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_KeyboardSendtextReply>(),
        interceptors: self.interceptors?.makesendtextInterceptors() ?? [],
        wrapping: self.sendtext(request:context:)
      )

    case "sendkeys":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Macbridge_KeyboardSendkeysInput>(),
        responseSerializer: ProtobufSerializer<Macbridge_KeyboardSendkeysReply>(),
        interceptors: self.interceptors?.makesendkeysInterceptors() ?? [],
        wrapping: self.sendkeys(request:context:)
      )

    default:
      return nil
    }
  }
}

#endif // compiler(>=5.6)

internal protocol Macbridge_KeyboardServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'sendtext'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makesendtextInterceptors() -> [ServerInterceptor<Macbridge_KeyboardSendtextInput, Macbridge_KeyboardSendtextReply>]

  /// - Returns: Interceptors to use when handling 'sendkeys'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makesendkeysInterceptors() -> [ServerInterceptor<Macbridge_KeyboardSendkeysInput, Macbridge_KeyboardSendkeysReply>]
}

internal enum Macbridge_KeyboardServerMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Keyboard",
    fullName: "macbridge.Keyboard",
    methods: [
      Macbridge_KeyboardServerMetadata.Methods.sendtext,
      Macbridge_KeyboardServerMetadata.Methods.sendkeys,
    ]
  )

  internal enum Methods {
    internal static let sendtext = GRPCMethodDescriptor(
      name: "sendtext",
      path: "/macbridge.Keyboard/sendtext",
      type: GRPCCallType.unary
    )

    internal static let sendkeys = GRPCMethodDescriptor(
      name: "sendkeys",
      path: "/macbridge.Keyboard/sendkeys",
      type: GRPCCallType.unary
    )
  }
}
